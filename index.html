<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Un Mensaje Para Vos</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Dancing+Script:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #000;
        }
        .font-dancing {
            font-family: 'Dancing Script', cursive;
        }
        #background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: linear-gradient(-45deg, #1b2735, #090a0f, #2c3e50, #23a6d5);
            background-size: 400% 400%;
            animation: gradient 20s ease infinite;
        }
        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .heart {
            width: 180px;
            height: 180px;
            transition: transform 0.2s ease-in-out;
            filter: drop-shadow(0 0 15px rgba(255, 20, 20, 0.7)) 
                    drop-shadow(0 0 40px rgba(255, 20, 20, 0.5));
        }
        .heart.beating {
            animation: beat 1.2s infinite cubic-bezier(0.215, 0.61, 0.355, 1);
        }
        @keyframes beat {
            0% { transform: scale(1); }
            15% { transform: scale(1.15); }
            30% { transform: scale(1); }
            45% { transform: scale(1.1); }
            60% { transform: scale(1); }
            100% { transform: scale(1); }
        }
        .progress-ring__circle {
            transition: stroke-dashoffset 0.35s;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
            filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.7));
        }
        .fade-in {
            animation: fadeInAnimation 2s ease-in forwards;
        }
        @keyframes fadeInAnimation {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-out {
            animation: fadeOutAnimation 1.5s ease-out forwards;
        }
        @keyframes fadeOutAnimation {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0; transform: scale(0.8); visibility: hidden; }
        }
        #globe-container {
            width: 100%;
            max-width: 400px;
            height: 400px;
            margin: -2rem auto 0;
            cursor: grab;
        }
        #globe-container:active {
            cursor: grabbing;
        }
    </style>
</head>
<body class="text-white flex items-center justify-center min-h-screen">
    <div id="background"></div>

    <!-- Pantalla Inicial -->
    <div id="start-screen" class="text-center p-8 flex flex-col items-center justify-center h-full">
        <h1 class="text-2xl md:text-4xl mb-4 font-bold">Para la dueña de mis pensamientos</h1>
        <p class="text-lg md:text-xl mb-12">Mantén presionado este corazón por 7 segundos...</p>
        <div id="heart-container" class="relative inline-flex items-center justify-center cursor-pointer select-none">
            <svg class="w-56 h-56 absolute">
                <circle class="text-transparent" stroke-width="8" stroke="rgba(255, 255, 255, 0.1)" fill="transparent" r="100" cx="112" cy="112"/>
                <circle id="progress-circle" class="progress-ring__circle text-white" stroke-width="8" stroke-linecap="round" stroke="currentColor" fill="transparent" r="100" cx="112" cy="112"/>
            </svg>
            <div id="heart-button" class="heart text-red-500">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
                </svg>
            </div>
        </div>
    </div>

    <!-- Pantalla de Mensaje -->
    <div id="message-screen" class="hidden text-center p-4 max-w-3xl mx-auto">
        <div id="globe-container"></div>
        <div class="bg-black bg-opacity-40 backdrop-blur-md rounded-2xl p-6 shadow-2xl mt-4">
            <h2 id="distance" class="text-3xl md:text-5xl font-bold text-cyan-300 mb-6"></h2>
            <p class="font-dancing text-3xl md:text-4xl leading-relaxed">
                "Sé que la distancia es enorme, y que tal vez tu corazón encuentre un nuevo hogar en Corea... pero sin importar cada uno de esos kilómetros, quiero que sepas que te extraño más de lo que las palabras pueden decir. Y aunque quieras estar con un coreano, este corazón sigue y seguirá latiendo por vos."
            </p>
        </div>
    </div>

    <script>
        // --- CONFIGURACIÓN INICIAL ---
        const heartContainer = document.getElementById('heart-container');
        const heartButton = document.getElementById('heart-button');
        const startScreen = document.getElementById('start-screen');
        const messageScreen = document.getElementById('message-screen');
        const distanceDisplay = document.getElementById('distance');
        
        const progressCircle = document.getElementById('progress-circle');
        const radius = progressCircle.r.baseVal.value;
        const circumference = radius * 2 * Math.PI;
        progressCircle.style.strokeDasharray = `${circumference} ${circumference}`;
        progressCircle.style.strokeDashoffset = circumference;

        let holdDuration = 0;
        const requiredHoldTime = 7000; // 7 segundos
        let interval;

        // --- DISTANCIA ---
        const distance = 19321;
        const formattedDistance = new Intl.NumberFormat('es-AR').format(distance);
        distanceDisplay.textContent = `${formattedDistance} km nos separan...`;

        // --- LÓGICA DE INTERACCIÓN ---
        function setProgress(percent) {
            const offset = circumference - (percent / 100) * circumference;
            progressCircle.style.strokeDashoffset = offset;
        }

        function startPress() {
            holdDuration = 0;
            setProgress(0);
            heartButton.classList.add('beating');
            
            const startTime = Date.now();
            interval = setInterval(() => {
                holdDuration = Date.now() - startTime;
                const progress = Math.min((holdDuration / requiredHoldTime) * 100, 100);
                setProgress(progress);

                if (holdDuration >= requiredHoldTime) {
                    showFinalMessage();
                    clearInterval(interval);
                }
            }, 50);
        }

        function cancelPress() {
            clearInterval(interval);
            heartButton.classList.remove('beating');
            setProgress(0);
        }

        function showFinalMessage() {
            startScreen.classList.add('fade-out');
            startScreen.addEventListener('animationend', () => {
                startScreen.classList.add('hidden');
                messageScreen.classList.remove('hidden');
                messageScreen.classList.add('fade-in');
                initGlobe(); // Iniciar la animación del globo
            }, { once: true });
        }

        // Event Listeners
        heartContainer.addEventListener('mousedown', startPress);
        heartContainer.addEventListener('mouseup', cancelPress);
        heartContainer.addEventListener('mouseleave', cancelPress);
        heartContainer.addEventListener('touchstart', (e) => { e.preventDefault(); startPress(); });
        heartContainer.addEventListener('touchend', cancelPress);
        heartContainer.addEventListener('touchcancel', cancelPress);

        // --- LÓGICA DEL GLOBO 3D (Three.js) ---
        function initGlobe() {
            const container = document.getElementById('globe-container');
            if (!container) return;

            // Escena, Cámara, Renderer
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.z = 3.5;

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Luces
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 3, 5);
            scene.add(directionalLight);

            // Globo
            const globeGeometry = new THREE.SphereGeometry(1.5, 64, 64);
            const globeMaterial = new THREE.MeshPhongMaterial({
                color: 0x2c3e50,
                shininess: 10
            });
            const globe = new THREE.Mesh(globeGeometry, globeMaterial);
            scene.add(globe);

            // Función para convertir Lat/Lon a coordenadas 3D
            function latLonToVector3(lat, lon, radius) {
                const phi = (90 - lat) * (Math.PI / 180);
                const theta = (lon + 180) * (Math.PI / 180);
                const x = -(radius * Math.sin(phi) * Math.cos(theta));
                const y = radius * Math.cos(phi);
                const z = radius * Math.sin(phi) * Math.sin(theta);
                return new THREE.Vector3(x, y, z);
            }

            // Coordenadas
            const myLocation = { lat: -34.6183, lon: -58.3780 }; // CABA
            const herLocation = { lat: 35.8315, lon: 129.2115 }; // Gyeongju
            const radiusGlobe = 1.5;

            const startPoint = latLonToVector3(myLocation.lat, myLocation.lon, radiusGlobe);
            const endPoint = latLonToVector3(herLocation.lat, herLocation.lon, radiusGlobe);

            // Marcadores
            const markerGeo = new THREE.SphereGeometry(0.03, 16, 16);
            const markerMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, emissive: 0x00ffff });
            
            const startMarker = new THREE.Mesh(markerGeo, markerMat);
            startMarker.position.copy(startPoint);
            scene.add(startMarker);

            const endMarker = new THREE.Mesh(markerGeo, markerMat);
            endMarker.position.copy(endPoint);
            scene.add(endMarker);

            // Arco entre puntos
            const arcHeight = 0.5;
            const midPoint = new THREE.Vector3().addVectors(startPoint, endPoint).multiplyScalar(0.5);
            const midLength = midPoint.length();
            midPoint.normalize().multiplyScalar(midLength + arcHeight);

            const curve = new THREE.CatmullRomCurve3([startPoint, midPoint, endPoint]);
            const tubeGeo = new THREE.TubeGeometry(curve, 64, 0.01, 8, false);
            const tubeMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 });
            const arc = new THREE.Mesh(tubeGeo, tubeMat);
            scene.add(arc);

            // Controles de mouse para rotar
            let isMouseDown = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            container.addEventListener('mousedown', e => { isMouseDown = true; });
            container.addEventListener('mouseup', e => { isMouseDown = false; });
            container.addEventListener('touchstart', e => { isMouseDown = true; });
            container.addEventListener('touchend', e => { isMouseDown = false; });

            container.addEventListener('mousemove', e => {
                if (!isMouseDown) return;
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                globe.rotation.y += deltaX * 0.005;
                globe.rotation.x += deltaY * 0.005;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
             container.addEventListener('touchmove', e => {
                if (!isMouseDown || !e.touches[0]) return;
                const touch = e.touches[0];
                const deltaX = touch.clientX - previousMousePosition.x;
                const deltaY = touch.clientY - previousMousePosition.y;
                globe.rotation.y += deltaX * 0.005;
                globe.rotation.x += deltaY * 0.005;
                previousMousePosition = { x: touch.clientX, y: touch.clientY };
            });

            // Animación
            function animate() {
                requestAnimationFrame(animate);
                if (!isMouseDown) {
                    globe.rotation.y += 0.001;
                }
                renderer.render(scene, camera);
            }
            animate();

            // Responsividad
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        }
    </script>
</body>
</html>
